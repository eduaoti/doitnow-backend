"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomerStatsbeatMetrics = void 0;
const tslib_1 = require("tslib");
const api_1 = require("@opentelemetry/api");
const sdk_metrics_1 = require("@opentelemetry/sdk-metrics");
const ai = tslib_1.__importStar(require("../../utils/constants/applicationinsights.js"));
const statsbeatMetrics_js_1 = require("./statsbeatMetrics.js");
const types_js_1 = require("./types.js");
const types_js_2 = require("./types.js");
const metricUtils_js_1 = require("../../utils/metricUtils.js");
const statsbeatExporter_js_1 = require("./statsbeatExporter.js");
const types_js_3 = require("../../types.js");
/**
 * Class that handles customer-facing statsbeat metrics
 * These metrics are sent to the customer's breeze endpoint
 *
 * Implements a singleton pattern to ensure only one set of customer statsbeat metrics
 * is exported every 15 minutes, regardless of the number of exporters or senders.
 */
class CustomerStatsbeatMetrics extends statsbeatMetrics_js_1.StatsbeatMetrics {
    static _instance;
    statsCollectionInterval = 900000; // 15 minutes
    customerStatsbeatMeter;
    customerStatsbeatMeterProvider;
    customerStatsbeatExporter;
    customerStatsbeatCounter;
    customerStatsbeatMetricReader;
    isInitialized = false;
    // Custom dimensions
    language;
    version;
    attach = (0, metricUtils_js_1.getAttachType)();
    // Observable Gauges
    itemSuccessCountGauge;
    itemDropCountGauge;
    itemRetryCountGauge;
    // Customer statsbeat properties
    customerProperties;
    constructor(options) {
        super();
        const exporterConfig = {
            connectionString: `InstrumentationKey=${options.instrumentationKey};IngestionEndpoint=${options.endpointUrl}`,
        };
        this.customerStatsbeatExporter = new statsbeatExporter_js_1.AzureMonitorStatsbeatExporter(exporterConfig);
        // Exports Customer Statsbeat every 15 minutes
        const customerMetricReaderOptions = {
            exporter: this.customerStatsbeatExporter,
            exportIntervalMillis: options.networkCollectionInterval || this.statsCollectionInterval,
        };
        this.customerStatsbeatMetricReader = new sdk_metrics_1.PeriodicExportingMetricReader(customerMetricReaderOptions);
        this.customerStatsbeatMeterProvider = new sdk_metrics_1.MeterProvider({
            readers: [this.customerStatsbeatMetricReader],
        });
        this.customerStatsbeatMeter = this.customerStatsbeatMeterProvider.getMeter("Azure Monitor Customer Statsbeat");
        this.language = types_js_2.STATSBEAT_LANGUAGE;
        this.version = ai.packageVersion;
        this.itemSuccessCountGauge = this.customerStatsbeatMeter.createObservableGauge(types_js_2.CustomStatsbeatCounter.ITEM_SUCCESS_COUNT);
        this.itemDropCountGauge = this.customerStatsbeatMeter.createObservableGauge(types_js_2.CustomStatsbeatCounter.ITEM_DROP_COUNT);
        this.itemRetryCountGauge = this.customerStatsbeatMeter.createObservableGauge(types_js_2.CustomStatsbeatCounter.ITEM_RETRY_COUNT);
        if (!this.isInitialized) {
            this.initialize();
        }
        this.isInitialized = true;
        // Initialize the single customer statsbeat counter
        this.customerStatsbeatCounter = new types_js_1.CustomerStatsbeat();
        this.customerProperties = {
            language: this.language,
            version: this.version,
            computeType: this.attach,
        };
    }
    /**
     * Get singleton instance of CustomerStatsbeatMetrics
     * @param options - Configuration options for customer statsbeat metrics
     * @returns The singleton instance
     */
    static getInstance(options) {
        if (!CustomerStatsbeatMetrics._instance) {
            CustomerStatsbeatMetrics._instance = new CustomerStatsbeatMetrics(options);
        }
        return CustomerStatsbeatMetrics._instance;
    }
    /**
     * Shutdown the singleton instance
     * Used for cleanup and complete shutdown
     */
    static shutdown() {
        if (CustomerStatsbeatMetrics._instance) {
            const shutdownPromise = CustomerStatsbeatMetrics._instance.shutdown();
            CustomerStatsbeatMetrics._instance = undefined;
            return shutdownPromise;
        }
        return undefined;
    }
    /**
     * Shuts down the customer statsbeat metrics provider
     * @returns Promise<void>
     */
    shutdown() {
        return this.customerStatsbeatMeterProvider.shutdown();
    }
    /**
     * Initializes the customer statsbeat metrics
     * Sets up the resource provider and adds observable callbacks for each metric
     * @returns Promise<void>
     */
    async initialize() {
        try {
            await super.getResourceProvider();
            this.customerStatsbeatMeter.addBatchObservableCallback(this.itemSuccessCallback.bind(this), [
                this.itemSuccessCountGauge,
            ]);
            this.customerStatsbeatMeter.addBatchObservableCallback(this.itemDropCallback.bind(this), [
                this.itemDropCountGauge,
            ]);
            this.customerStatsbeatMeter.addBatchObservableCallback(this.itemRetryCallback.bind(this), [
                this.itemRetryCountGauge,
            ]);
        }
        catch (error) {
            api_1.diag.debug("Call to get the resource provider failed for customer statsbeat metrics.");
        }
    }
    // Observable gauge callbacks
    itemSuccessCallback(observableResult) {
        const counter = this.customerStatsbeatCounter;
        const attributes = { ...this.customerProperties, telemetry_type: types_js_2.TelemetryType.UNKNOWN };
        // For each { telemetry_type -> count } mapping, call observe, passing the count and attributes that include the telemetry_type
        for (const [telemetry_type, count] of counter.totalItemSuccessCount.entries()) {
            attributes.telemetry_type = telemetry_type;
            observableResult.observe(this.itemSuccessCountGauge, count, {
                ...attributes,
            });
            counter.totalItemSuccessCount.set(telemetry_type, 0);
        }
    }
    itemDropCallback(observableResult) {
        const counter = this.customerStatsbeatCounter;
        const baseAttributes = {
            ...this.customerProperties,
            "drop.code": types_js_1.DropCode.UNKNOWN,
            telemetry_type: types_js_2.TelemetryType.UNKNOWN,
        };
        // Iterate through the nested Map structure: telemetry_type -> drop.code -> reason -> count
        for (const [telemetryType, dropCodeMap] of counter.totalItemDropCount.entries()) {
            for (const [dropCode, reasonMap] of dropCodeMap.entries()) {
                for (const [reason, count] of reasonMap.entries()) {
                    const attributes = { ...baseAttributes };
                    attributes.telemetry_type = telemetryType;
                    attributes["drop.code"] = dropCode;
                    // Include drop.reason for all case
                    if (reason) {
                        attributes["drop.reason"] = reason;
                    }
                    observableResult.observe(this.itemDropCountGauge, count, {
                        ...attributes,
                    });
                    // Reset the count to 0
                    reasonMap.set(reason, 0);
                }
            }
        }
    }
    itemRetryCallback(observableResult) {
        const counter = this.customerStatsbeatCounter;
        const baseAttributes = {
            ...this.customerProperties,
            "retry.code": types_js_1.RetryCode.UNKNOWN,
            telemetry_type: types_js_2.TelemetryType.UNKNOWN,
        };
        // Iterate through the nested Map structure: telemetry_type -> retry.code -> reason -> count
        for (const [telemetryType, retryCodeMap] of counter.totalItemRetryCount.entries()) {
            for (const [retryCode, reasonMap] of retryCodeMap.entries()) {
                for (const [reason, count] of reasonMap.entries()) {
                    const attributes = { ...baseAttributes };
                    attributes.telemetry_type = telemetryType;
                    attributes["retry.code"] = retryCode;
                    // Include retry.reason for all cases
                    if (reason) {
                        attributes["retry.reason"] = reason;
                    }
                    observableResult.observe(this.itemRetryCountGauge, count, {
                        ...attributes,
                    });
                    // Reset the count to 0
                    reasonMap.set(reason, 0);
                }
            }
        }
    }
    // Public methods to track metrics
    /**
     * Tracks succcessful items
     * @param envelopes - Number of successful envelopes
     * @param telemetry_type - The type of telemetry being tracked
     */
    countSuccessfulItems(envelopes) {
        const counter = this.customerStatsbeatCounter;
        let telemetry_type;
        // Get the current count for this telemetry type, or 0 if it doesn't exist
        for (const envelope of envelopes) {
            telemetry_type = this.getTelemetryTypeFromEnvelope(envelope);
            const currentCount = counter.totalItemSuccessCount.get(telemetry_type) || 0;
            counter.totalItemSuccessCount.set(telemetry_type, currentCount + 1);
        }
    }
    /**
     * Tracks dropped items
     * @param envelopes - Number of envelopes dropped
     * @param dropCode - The drop code indicating the reason for drop
     * @param telemetry_type - The type of telemetry being tracked
     * @param exceptionMessage - Optional exception message when dropCode is CLIENT_EXCEPTION
     */
    countDroppedItems(envelopes, dropCode, exceptionMessage) {
        const counter = this.customerStatsbeatCounter;
        let telemetry_type;
        for (const envelope of envelopes) {
            telemetry_type = this.getTelemetryTypeFromEnvelope(envelope);
            // Get or create the dropCode map for this telemetry_type
            let dropCodeMap = counter.totalItemDropCount.get(telemetry_type);
            if (!dropCodeMap) {
                dropCodeMap = new Map();
                counter.totalItemDropCount.set(telemetry_type, dropCodeMap);
            }
            // Get or create the reason map for this dropCode
            let reasonMap = dropCodeMap.get(dropCode);
            if (!reasonMap) {
                reasonMap = new Map();
                dropCodeMap.set(dropCode, reasonMap);
            }
            // Generate a low-cardinality, informative reason description
            const reason = this.getDropReason(dropCode, exceptionMessage);
            // Update the count for this reason
            const currentCount = reasonMap.get(reason) || 0;
            reasonMap.set(reason, currentCount + 1);
        }
    }
    /**
     * Generates a low-cardinality, informative description for drop reasons
     * @param dropCode - The drop code (enum value or status code number)
     * @param exceptionMessage - Optional exception message for CLIENT_EXCEPTION
     * @returns A descriptive reason string with low cardinality
     */
    getDropReason(dropCode, exceptionMessage) {
        if (dropCode === types_js_1.DropCode.CLIENT_EXCEPTION) {
            // For client exceptions, derive a low-cardinality reason from the exception message
            if (exceptionMessage) {
                return this.categorizeExceptionMessage(exceptionMessage);
            }
            return "unknown_exception";
        }
        // Handle status code drop codes (numeric values)
        if (typeof dropCode === "number") {
            return this.categorizeStatusCode(dropCode);
        }
        // Handle other enum drop codes
        switch (dropCode) {
            case types_js_1.DropCode.CLIENT_EXPIRED_DATA:
                return "expired_data";
            case types_js_1.DropCode.CLIENT_READONLY:
                return "readonly_mode";
            case types_js_1.DropCode.CLIENT_STALE_DATA:
                return "stale_data";
            case types_js_1.DropCode.CLIENT_PERSISTENCE_CAPACITY:
                return "persistence_full";
            case types_js_1.DropCode.NON_RETRYABLE_STATUS_CODE:
                return "non_retryable_status";
            case types_js_1.DropCode.UNKNOWN:
            default:
                return "unknown_reason";
        }
    }
    /**
     * Categorizes exception messages into low-cardinality groups
     * @param exceptionMessage - The exception message to categorize
     * @returns A low-cardinality category string
     */
    categorizeExceptionMessage(exceptionMessage) {
        const message = exceptionMessage.toLowerCase();
        if (message.includes("timeout") || message.includes("timed out")) {
            return "timeout_exception";
        }
        if (message.includes("network") || message.includes("connection")) {
            return "network_exception";
        }
        if (message.includes("auth") ||
            message.includes("unauthorized") ||
            message.includes("forbidden")) {
            return "auth_exception";
        }
        if (message.includes("parsing") || message.includes("parse") || message.includes("invalid")) {
            return "parsing_exception";
        }
        if (message.includes("disk") || message.includes("storage") || message.includes("file")) {
            return "storage_exception";
        }
        if (message.includes("memory") || message.includes("out of memory")) {
            return "memory_exception";
        }
        return "other_exception";
    }
    /**
     * Categorizes HTTP status codes into informative descriptions
     * @param statusCode - The HTTP status code
     * @returns A descriptive category string
     */
    categorizeStatusCode(statusCode) {
        if (statusCode >= 400 && statusCode < 500) {
            switch (statusCode) {
                case 400:
                    return "bad_request";
                case 401:
                    return "unauthorized";
                case 403:
                    return "forbidden";
                case 404:
                    return "not_found";
                case 408:
                    return "request_timeout";
                case 413:
                    return "payload_too_large";
                case 429:
                    return "too_many_requests";
                default:
                    return "client_error_4xx";
            }
        }
        if (statusCode >= 500 && statusCode < 600) {
            switch (statusCode) {
                case 500:
                    return "internal_server_error";
                case 502:
                    return "bad_gateway";
                case 503:
                    return "service_unavailable";
                case 504:
                    return "gateway_timeout";
                default:
                    return "server_error_5xx";
            }
        }
        return `status_${statusCode}`;
    }
    /**
     * Tracks retried envelopes
     * @param envelopes - Number of envelopes retried
     * @param retryCode - The retry code indicating the reason for retry
     * @param telemetry_type - The type of telemetry being tracked
     * @param exceptionMessage - Optional exception message when retryCode is CLIENT_EXCEPTION
     */
    countRetryItems(envelopes, retryCode, exceptionMessage) {
        const counter = this.customerStatsbeatCounter;
        let telemetry_type;
        for (const envelope of envelopes) {
            telemetry_type = this.getTelemetryTypeFromEnvelope(envelope);
            // Get or create the retryCode map for this telemetry_type
            let retryCodeMap = counter.totalItemRetryCount.get(telemetry_type);
            if (!retryCodeMap) {
                retryCodeMap = new Map();
                counter.totalItemRetryCount.set(telemetry_type, retryCodeMap);
            }
            // Get or create the reason map for this retryCode
            let reasonMap = retryCodeMap.get(retryCode);
            if (!reasonMap) {
                reasonMap = new Map();
                retryCodeMap.set(retryCode, reasonMap);
            }
            // Generate a low-cardinality, informative reason description
            const reason = this.getRetryReason(retryCode, exceptionMessage);
            // Update the count for this reason
            const currentCount = reasonMap.get(reason) || 0;
            reasonMap.set(reason, currentCount + 1);
        }
    }
    /**
     * Generates a low-cardinality, informative description for retry reasons
     * @param retryCode - The retry code (enum value or status code number)
     * @param exceptionMessage - Optional exception message for CLIENT_EXCEPTION
     * @returns A descriptive reason string with low cardinality
     */
    getRetryReason(retryCode, exceptionMessage) {
        if (retryCode === types_js_1.RetryCode.CLIENT_EXCEPTION) {
            // For client exceptions, derive a low-cardinality reason from the exception message
            if (exceptionMessage) {
                return this.categorizeExceptionMessage(exceptionMessage);
            }
            return "unknown_exception";
        }
        // Handle status code retry codes (numeric values)
        if (typeof retryCode === "number") {
            return this.categorizeStatusCode(retryCode);
        }
        // Handle other enum retry codes
        switch (retryCode) {
            case types_js_1.RetryCode.CLIENT_TIMEOUT:
                return "client_timeout";
            case types_js_1.RetryCode.RETRYABLE_STATUS_CODE:
                return "retryable_status";
            case types_js_1.RetryCode.UNKNOWN:
            default:
                return "unknown_reason";
        }
    }
    /**
     * Check if a metric name corresponds to a performance counter
     * @param metricName - The name of the metric to check
     * @returns true if the metric name is a performance counter, false otherwise
     */
    isPerformanceCounterMetric(metricName) {
        return Object.values(types_js_3.BreezePerformanceCounterNames).includes(metricName);
    }
    /**
     * Extract telemetry type from an envelope based on its baseType
     * @param envelope - The envelope to extract telemetry type from
     * @returns The corresponding telemetry type
     */
    getTelemetryTypeFromEnvelope(envelope) {
        if (envelope.data && envelope.data.baseType) {
            switch (envelope.data.baseType) {
                case "MessageData":
                    return types_js_2.TelemetryType.TRACE;
                case "AvailabilityData":
                    return types_js_2.TelemetryType.AVAILABILITY;
                case "TelemetryEventData":
                    return types_js_2.TelemetryType.CUSTOM_EVENT;
                case "TelemetryExceptionData":
                    return types_js_2.TelemetryType.EXCEPTION;
                case "PageViewData":
                    return types_js_2.TelemetryType.PAGE_VIEW;
                case "RemoteDependencyData":
                    return types_js_2.TelemetryType.DEPENDENCY;
                case "RequestData":
                    return types_js_2.TelemetryType.REQUEST;
                case "MetricData": {
                    const metricsData = envelope.data.baseData;
                    if (metricsData && metricsData.metrics && metricsData.metrics.length > 0) {
                        // Check if any of the metrics are performance counters
                        const hasPerformanceCounter = metricsData.metrics.some((metric) => this.isPerformanceCounterMetric(metric.name));
                        return hasPerformanceCounter
                            ? types_js_2.TelemetryType.PERFORMANCE_COUNTER
                            : types_js_2.TelemetryType.CUSTOM_METRIC;
                    }
                    return types_js_2.TelemetryType.CUSTOM_METRIC;
                }
                default:
                    return types_js_2.TelemetryType.UNKNOWN;
            }
        }
        return types_js_2.TelemetryType.UNKNOWN;
    }
    /**
     * Checks if the given error is a timeout-related error
     * @param error - The error to check
     * @returns true if the error is timeout-related, false otherwise
     */
    isTimeoutError(error) {
        // Check for various timeout error codes that indicate client timeouts
        const timeoutErrorCodes = [
            "ETIMEDOUT", // Connection timed out
            "ESOCKETTIMEDOUT", // Socket timeout
            "ECONNRESET", // Connection reset (often due to timeout)
            "ENOTFOUND", // DNS lookup failed/timeout
        ];
        if (error && error.code && timeoutErrorCodes.includes(error.code)) {
            return true;
        }
        // Also check if the error message contains timeout-related keywords
        if (error && error.message) {
            const timeoutKeywords = ["timeout", "timed out", "connection reset"];
            const errorMessage = error.message.toLowerCase();
            return timeoutKeywords.some((keyword) => errorMessage.includes(keyword));
        }
        return false;
    }
}
exports.CustomerStatsbeatMetrics = CustomerStatsbeatMetrics;
//# sourceMappingURL=customerStatsbeat.js.map